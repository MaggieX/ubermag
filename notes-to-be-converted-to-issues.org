* Design review field class <2016-11-03 Thu 02:31> (GMT), New Orleans

Marijan Beg, Mark Vousden, Hans Fangohr

** Interface field m
- m(r) with r = (x, y, z)
- m.value is part of field, and supports constant tuple and function
- m.value -> tuple, function, many tuples, array
  (Example:

  m.value = lamba r: (1, 0, 0)
  m.array[0,0,0] = 42
  m.value should return array now
)

if m.value is function, and the user asks for the array
- m.array -> numpy array (ref, not copy)
- m.mesh.coordinates -> tuples of float
-       .indices -> tuples of int

m.array[23,3,4]=42.0


** Normalisation

system = oc.System(name="stdprob3")
system.mesh = mesh
system.hamiltonian = oc.Exchange(A) + oc.UniaxialAnisotropy(K, u) + oc.Demag()
system.m = df.Field(mesh, value=m_init, normalisedto=Ms)

** Mesh in system
Take 'mesh' from m.mesh

system = oc.System(name="stdprob3")
# system.mesh = mesh
system.hamiltonian = oc.Exchange(A) + oc.UniaxialAnisotropy(K, u) + oc.Demag()
system.m = df.Field(mesh, value=m_init, norm=Ms)

system.m = df.Field(mesh, value=m_init)  # compute norm based on norm
                                         # of m_init

** Make norm a property:

m.norm -> norm of all vectors (array)
m.norm = n   # normalise vectors so that m.norm == n

** average

m.average -> spatial average (something like tuple(m.array.mean()))

** m.f -> m._f
** use structured array
m['x'] -> x-components of all vectors
** __repr__ -> as now, but include m.name
** representation in notebook: holoviews object
** m.name -> set with 'm' if system.m = Field
          set as 'H_exchange', 'H_Demag' etc

** plot_line_intersection: get rid of show() command
to stop figure appearing twice

** Review interface of plot_line_intersection and line_intersection later

* <2016-11-03 Thu>

** How to get exchange energy from given m?

These are issues #9 and #10 in micromagnetic model

system.m = Field()
system.m = (1, 0, 0)
# get energy:  -> float
system.hamiltonian.exchange.energy.
# energy densisty -> scalar field
system.hamiltonian.exchange.energy_density
# get exchange field -> vector field
system.hamiltonian.exchange.field
# needs calling of OOMMF

Step 1: implement this naively
- everytime hamiltonian.INTERACTION.field, or - everytime
  hamiltonian.INTERACTION.energy or - everytime
  hamiltonian.INTERACTION.energy_density is called, we execute OOMMF
  to retrieve that information.

Step 2: develop an dependency engine
- have some flag somewhere that records whether
  - m
  - H
  - or interaction terms
  have changed since we computed interaction data last with OOMMF

- if the user requests any of the computed interactions, we check
  whether we have cached data that is still up-to-date. If so, we
  return the cached data. If not, we call OOMMF to compute the
  interaction values.

- Whenever we call OOMMF, we store all fields, energies and energy
  densities to disk and cache them.

** Terms and conditions

- run: integer starting from 0. Increases everytime before we call
  OOMMF.

** File structure layout for multiple (calculator runs)
- for a simulation run with name NAME, we have the following structure

  /NAME/1
  /NAME/2
  /NAME/3
  /NAME/4

  Each subdirectory contains one OOMMF run, including the mif file,
  the odt file, and all OMF files.

  We may try to dump a textual summary of the micromagnetic model in
  there as well.


** The data table (dt or data.table?)
- lives is system.dt
- create pandas table that brings together all the data from the odt
  files in the NAME/* directories
- pandas table should contain:
  - run number
  - accumulate time if possible
  - all the odt data
  - missing data will be NaN; pandas should do this automatically

** Data analysis
Example
  md.drive(system)
  system.dt.plot['t', 'mx']

  d = Data('stdprob3')
  d = Data(system)

  d is the same as

  system.data

** How to find spatially resolved data?
Extend the data.table to include an extra column for every saved omf
field (i.e. one column for demag field, one for demag energy density,
one for magentisation), which contains the name of the file containing
the data, and is empty if no data was saved.

To retrieve a spatially resolved field, we 'just' need to identify the
right row. Should offer some options to do that, ideally using pandas.

Should be able to extend this so that if the user specification
returns not just one row, but multiple ones, we return a list of field
objects.

Possible syntax

# use pandas syntax
rows = data.table(run=4 && have('demag'))
# new functionality from
data.field('demag', rows) to return list of field objects

Location: keep the Data class in the oommfc repository FOR NOW, but
move into its own repository when it has evolved a little.

This data analysis tool will be useful on its own (i.e. outside the
OOMMFC context) to OOMMF users.
